import os
import requests
import json
from flask import Flask, request, redirect
from markupsafe import Markup
import mistune
from dotenv import load_dotenv
from datetime import datetime, timedelta

import vertexai
from vertexai.generative_models import GenerativeModel

load_dotenv()

app = Flask(__name__)

# --- Configuration ---
STRAVA_CLIENT_ID = os.getenv("STRAVA_CLIENT_ID")
STRAVA_CLIENT_SECRET = os.getenv("STRAVA_CLIENT_SECRET")
STRAVA_API_URL = "https://www.strava.com/api/v3"
REDIRECT_URI = "http://127.0.0.1:5000/callback"
SCOPES = "read,activity:read_all,profile:read_all"

GCP_PROJECT_ID = "my-personal-coach-472007"
GCP_LOCATION = "europe-west1"
DATA_CACHE_FILE = "strava_data.json"

# --- Initialize Vertex AI ---
vertexai.init(project=GCP_PROJECT_ID, location=GCP_LOCATION)
# Using the more powerful model as requested
model = GenerativeModel(model_name="gemini-2.5-pro")

# --- Helper & Analysis Functions ---

def format_seconds(seconds):
    """Converts seconds into a human-readable Xh Ym Zs format."""
    seconds = int(seconds)
    if seconds == 0: return "0s"
    hours = seconds // 3600
    minutes = (seconds % 3600) // 60
    secs = seconds % 60
    parts = []
    if hours > 0: parts.append(f"{hours}h")
    if minutes > 0: parts.append(f"{minutes}m")
    if secs > 0: parts.append(f"{secs}s")
    return " ".join(parts)

def get_strava_api_data(access_token, endpoint):
    """Generic function to fetch data from Strava API."""
    headers = {'Authorization': f'Bearer {access_token}'}
    response = requests.get(f"{STRAVA_API_URL}/{endpoint}", headers=headers)
    response.raise_for_status()
    return response.json()

def get_activity_streams(access_token, activity_id):
    """Fetches streams for a single activity."""
    headers = {'Authorization': f'Bearer {access_token}'}
    params = {'keys': 'heartrate,time,watts', 'key_by_type': True}
    response = requests.get(f"{STRAVA_API_URL}/activities/{activity_id}/streams", headers=headers, params=params)
    return response.json() if response.status_code == 200 else None

def get_athlete_stats(access_token, athlete_id):
    """Fetches the athlete's historical stats."""
    return get_strava_api_data(access_token, f"athletes/{athlete_id}/stats")

def map_race_distance(distance_meters):
    """Maps a race distance to the nearest standard event."""
    if 4875 <= distance_meters <= 5125: return "5k Race"
    if 9750 <= distance_meters <= 10250: return "10k Race"
    if 20570 <= distance_meters <= 21625: return "Half Marathon Race"
    if 41140 <= distance_meters <= 43250: return "Marathon Race"
    return "Race (Non-Standard Distance)"

def calculate_friel_hr_zones(lthr):
    """Calculates running HR zones based on Joe Friel's method."""
    return {
        "zones": [
            {"min": 0, "max": int(lthr * 0.85), "label": "Zone 1"},
            {"min": int(lthr * 0.85), "max": int(lthr * 0.89), "label": "Zone 2"},
            {"min": int(lthr * 0.90), "max": int(lthr * 0.94), "label": "Zone 3"},
            {"min": int(lthr * 0.95), "max": int(lthr * 1), "label": "Zone 4"},
            {"min": int(lthr * 1), "max": -1, "label": "Zone 5"}
        ],
        "calculation_method": f"Joe Friel (LTHR: {lthr} bpm)"
    }

def calculate_friel_power_zones(ftp):
    """Calculates cycling power zones based on Joe Friel's FTP percentages."""
    return {
        "zones": [
            {"min": 0, "max": int(ftp * 0.55), "label": "Zone 1"},
            {"min": int(ftp * 0.55), "max": int(ftp * 0.74), "label": "Zone 2"},
            {"min": int(ftp * 0.75), "max": int(ftp * 0.89), "label": "Zone 3"},
            {"min": int(ftp * 0.90), "max": int(ftp * 1.04), "label": "Zone 4"},
            {"min": int(ftp * 1.05), "max": int(ftp * 1.20), "label": "Zone 5"},
            {"min": int(ftp * 1.20), "max": int(ftp * 1.50), "label": "Zone 6"},
            {"min": int(ftp * 1.50), "max": -1, "label": "Zone 7"}
        ],
        "calculation_method": f"Joe Friel (Estimated FTP: {ftp} W)"
    }

def analyze_activity(activity, streams, zones):
    """Analyzes a single activity and its streams to create a rich object."""
    analyzed = {"id": activity['id'], "name": activity['name'], "type": activity['type'],
                "start_date": activity['start_date_local'], "is_race": activity.get('workout_type') == 1,
                "distance_km": round(activity.get('distance', 0) / 1000, 2),
                "moving_time_minutes": round(activity.get('moving_time', 0) / 60, 2),
                "time_in_hr_zones": {i: 0 for i in range(5)}, "time_in_power_zones": {i: 0 for i in range(7)}}
    if analyzed["is_race"]: analyzed["race_tag"] = map_race_distance(activity['distance'])
    if not streams: return analyzed
    time_data = streams.get('time', {}).get('data', [])
    if not time_data: return analyzed

    if 'heartrate' in streams:
        hr_data = streams['heartrate']['data']
        hr_zones = zones.get('heart_rate', {}).get('zones', [])
        for i in range(1, len(hr_data)):
            duration, hr = time_data[i] - time_data[i-1], hr_data[i-1]
            zone_index = 0
            for j, z in enumerate(hr_zones):
                if z.get('max', -1) == -1:
                    if hr >= z['min']: zone_index = j
                elif hr >= z['min'] and hr < z['max']:
                    zone_index = j
                    break
            analyzed["time_in_hr_zones"][zone_index] += duration
            
    if 'watts' in streams:
        power_data = streams['watts']['data']
        power_zones = zones.get('power', {}).get('zones', [])
        for i in range(1, len(power_data)):
            duration, power = time_data[i] - time_data[i-1], power_data[i-1]
            zone_index = 0
            for j, z in enumerate(power_zones):
                 if z.get('max', -1) == -1:
                    if power >= z['min']: zone_index = j
                 elif power >= z['min'] and power < z['max']:
                    zone_index = j
                    break
            analyzed["time_in_power_zones"][zone_index] += duration

    return analyzed

def find_valid_race_for_vdot(activities, access_token, friel_hr_zones):
    """Finds a recent, high-intensity race suitable for VDOT calculation."""
    four_weeks_ago = datetime.now() - timedelta(weeks=4)
    for activity in activities:
        activity_date_str = activity['start_date_local'].split('T')[0]
        activity_date = datetime.strptime(activity_date_str, '%Y-%m-%d')
        if activity.get('workout_type') == 1 and activity_date > four_weeks_ago:
            streams = get_activity_streams(access_token, activity['id'])
            if streams and 'heartrate' in streams:
                race_analysis = analyze_activity(activity, streams, {"heart_rate": friel_hr_zones})
                total_time = sum(race_analysis['time_in_hr_zones'].values())
                high_intensity_time = race_analysis['time_in_hr_zones'][3] + race_analysis['time_in_hr_zones'][4]
                if total_time > 0 and (high_intensity_time / total_time) > 0.5:
                    return {"status": "VDOT Ready", "race_basis": f"{activity['name']} ({activity_date_str})"}
    return {"status": "HR Training Recommended", "reason": "No recent, high-intensity race found to build a reliable VDOT score."}

# --- Flask Routes ---

@app.route("/")
def home():
    return '<a href="/login">Login with Strava</a>'

@app.route("/login")
def login():
    auth_redirect_url = (f"https://www.strava.com/oauth/authorize?client_id={STRAVA_CLIENT_ID}"
                       f"&redirect_uri={REDIRECT_URI}&response_type=code&scope={SCOPES}")
    return redirect(auth_redirect_url)

@app.route("/callback")
def callback():
    try:
        # --- Simulate User Input ---
        user_goal = "10k road race in under 39 minutes"
        user_target_race = "Local 10k"
        user_race_date = "2026-03-15"
        user_known_lthr = 160
        user_known_ftp = 200
        user_sessions_per_week = 5 # 3 runs, 2 S&C

        # --- Data Caching Logic ---
        if os.path.exists(DATA_CACHE_FILE):
            print("--- Loading data from cache file ---")
            with open(DATA_CACHE_FILE, 'r') as f:
                final_data_for_ai = json.load(f)
        else:
            print("--- Fetching new data from Strava API ---")
            auth_code = request.args.get('code')
            if not auth_code:
                return "Authentication error: No code provided. Please try logging in again."
                
            token_payload = {"client_id": STRAVA_CLIENT_ID, "client_secret": STRAVA_CLIENT_SECRET,
                             "code": auth_code, "grant_type": "authorization_code"}
            token_response = requests.post("https://www.strava.com/oauth/token", data=token_payload)
            token_response.raise_for_status()
            
            token_data = token_response.json()
            access_token = token_data['access_token']
            athlete_id = token_data['athlete']['id']

            strava_zones = get_strava_api_data(access_token, "athlete/zones")
            activities_summary = get_strava_api_data(access_token, f"athlete/activities?per_page=60")
            athlete_stats = get_athlete_stats(access_token, athlete_id)
            
            friel_hr_zones = calculate_friel_hr_zones(user_known_lthr)
            friel_power_zones = calculate_friel_power_zones(user_known_ftp)

            vdot_data = find_valid_race_for_vdot(activities_summary, access_token, friel_hr_zones)
            
            analyzed_activities = []
            for activity in activities_summary:
                streams = get_activity_streams(access_token, activity['id'])
                all_friel_zones = {"heart_rate": friel_hr_zones, "power": friel_power_zones}
                analyzed_activity = analyze_activity(activity, streams, all_friel_zones)
                
                for i, seconds in analyzed_activity["time_in_hr_zones"].items():
                    analyzed_activity["time_in_hr_zones"][i] = format_seconds(seconds)
                for i, seconds in analyzed_activity["time_in_power_zones"].items():
                    analyzed_activity["time_in_power_zones"][i] = format_seconds(seconds)
                analyzed_activities.append(analyzed_activity)

            final_data_for_ai = {
                "athlete_goal": user_goal,
                "sessions_per_week": user_sessions_per_week,
                "strava_zones": strava_zones,
                "friel_hr_zones": friel_hr_zones,
                "friel_power_zones": friel_power_zones,
                "vdot_data": vdot_data,
                "vdot_paces": {"Easy": "5:30-6:10 min/km", "Threshold": "4:45 min/km", "Interval": "4:20 min/km"} if vdot_data["status"] == "VDOT Ready" else None,
                "analyzed_activities": analyzed_activities
            }

            # Save the new data to the cache file
            with open(DATA_CACHE_FILE, 'w') as f:
                json.dump(final_data_for_ai, f, indent=4)
        
        # --- Prompt and AI Call ---
        prompt = f"""
        You are an elite endurance coach. Your tone is **direct, objective, and pragmatic, like a seasoned British coach. Avoid conversational fluff and get straight to the point, but don't be rude or overly aggresive**. You have decades of experience coaching athletes to their best performances, specialising in running and cycling. You understand the science of training, recovery, and periodization deeply.

        Your training philosophy is a **synthesis of modern, evidence-based methodologies**:
        - **Structure:** Polarized training (80/20).
        - **Effort (HR):** Joe Friel's LTHR-based heart rate zones.
        - **Pace (Running):** Dr. Jack Daniels' VDOT-based paces once a baseline is set.
        
        **Your primary task is to generate a personalized training plan.** Structure your response with the following markdown headings:

        ### Fitness Assessment & Goal Viability
        Briefly assess current fitness and comment on the viability of the stated `athlete_goal`. Take into account the athlete's long term experience, understand how long they have been active for and what their experience is. Use the `analyzed_activities` to determine current fitness, focusing on recent training load and intensity distribution. recent training is a better indicator of current fitness and what they can achieve, however take into account their long term experience and hostory to understand what is possible.  If the athlete has a history of multisport, consider how this may have contributed to their aerobic base and overall fitness.  If they have a history of running, consider how this may have contributed to their running economy and efficiency.  If they have a history of cycling, consider how this may have contributed to their muscular endurance and power.  

        ### Training Pace & Zone Recommendations
        - First, advise the athlete to update their Strava zones to match the Friel calculations only if they differ by more than 3 bpm per value in each zone range. Show a clear comparison table.
        - Check `vdot_data.status`. If "HR Training Recommended", recommend a 5k time trial in 3 - 4 weeks to establish a VDOT baseline.

        ### {final_data_for_ai['athlete_goal']} Training Plan: Weeks 1-6
        **You MUST generate a 6-week plan.**
        **DO NOT assign workouts to specific days.** List the sessions for each week for the athlete to schedule. Emphasise the importance of key sessions, recommend S&C is done on days that are easy or rest days, and ensure adequate recovery between hard sessions.
        **Clearly mark each session as [KEY], [IMPORTANT], or [STRETCH].** If and when the athlete's fitness can support it encourage the adoption of double threshold days like the Norwegian method uses, this is especially effective for 10km plus running events.

        **S&C Plan:**
        You must provide four distinct, full-body S&C routines, ideally a library of individual exercises that can act like a pick and mix. For each routine, list 4-5 specific exercises with sets and reps (e.g., "Bodyweight Squats: 3 sets of 15 reps"). The exercises must require minimal or no equipment, but you should also provide a gym-based alternative ideally using a standard resistance based machine that you'd find in a UK gym for each (e.g., "or Leg Press Machine"). The goal is functional strength and injury resilience.  Mix it up a bit, try and keep it interesting, if there are a number of routines to choose from, highlight which one should be priority each week
        

        **Plan Structure Rules:**
        1.  **Run Focus:** The athlete's goal is {final_data_for_ai['athlete_goal']} and they plan to train {final_data_for_ai['sessions_per_week']} times per week. The plan must include at least **{final_data_for_ai['sessions_per_week'] + 2}** productive fitness appropriate sessions including 1 or 2 Jack Daniel style "Q" or quality sessions as appropriate for current fitness and goals** and **at least 2 S&C sessions with 1 being marked as important** per week. Include cross training sessions appropriately. Ensure the plan is balanced and allows for adequate recovery. Consider if history shows a multisport background, there may be a desire to continue this in the future.  Take the athlete's history into account and create a truly bespoke plan for their aptitude and experience.
        2.  **Zone Discipline:** Recovery = **Zone 1**. Easy/Aerobic = **Zone 2**. Threshold = **Zone 4**. VO2 Max = **Zone 5**. **DO NOT prescribe workouts with a primary target of Zone 3.** Think Joel Friel and Dr. Jack Daniels, consider the Norwegian method, prioritise polarised training, and avoid the "grey zone".
        3.  **Prioritization:**
            - **[KEY]** sessions are the Jack Daniels Q sessions.  Quality sessions that will make the big differences to performance.
            - **[IMPORTANT]** sessions are the mostly Zone 2, building endurance, time doing the relative sport that will make gradual improvements to performance over time, but if missed now and then won't have a direct immediate impact.
            - **[STRETCH]** sessions are all other beneficial sessions if recovery, time and schedule allow but if missed won't have a big impactand also the second (or more) S&C session(s).
        4.  **Cautious Progression:** The plan must be appropriate for the athlete's current fitness level, based on the history analysed, give higher consideration to more recent training to ascertain their curent level of fitness, typically the last 4 - 6 weeks of training so you know the current capabilities. Start with conservative durations.  It's better to build fitness and motivation slowly, rather than demoralising with sessions that are too hard or picking up an injury
        
        Here is the data:
        ```json
        {json.dumps(final_data_for_ai, indent=4)}
        ```
        IMPORTANT: Your entire response must be in Markdown format.
        """
        
        response = model.generate_content(prompt)
        
        return Markup(mistune.html(response.text))

    except Exception as e:
        return f"An error occurred: {e}", 500

if __name__ == "__main__":
    app.run(debug=True, port=5000)